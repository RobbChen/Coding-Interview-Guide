## 按照左右半区的方式重新组合单链表

**题目：**
>给定一个单链表的头部节点head,链表长度为N，如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区；如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区。左半区从左到右依次记为Ll->L2->…，右半区从左到右依次记为Rt->R2->…，请将单链表调整成L1->R1->L2->R2->…的形式。
```
例如：
1->null，调整为1->null.
1->2->null，调整为l->2->null。
l->2->3->null，调整为1->2->3->null。
1->2->3->4->null，调整为1->3->2->4->null。
l->2->3->4->5->null，调整为1->3->2->4->5->null。
1->2->3->4->5->6->null，调整为1->4->2->5->3->6->null.
```


```
public class Problem_20_SortedRatateArrayFindNum {

	public static boolean isContains(int[] arr, int num) {
		int low = 0;
		int high = arr.length - 1;
		int mid = 0;
		while (low <= high) {
			mid = (low + high) / 2;
			if (arr[mid] == num) {
				return true;
			}
			if (arr[low] == arr[mid] && arr[mid] == arr[high]) {
				while (low != mid && arr[low] == arr[mid]) {
					low++;
				}
				if (low == mid) {
					low = mid + 1;
					continue;
				}
			}
			if (arr[low] != arr[mid]) {
				if (arr[mid] > arr[low]) {
					if (num >= arr[low] && num < arr[mid]) {
						high = mid - 1;
					} else {
						low = mid + 1;
					}
				} else {
					if (num > arr[mid] && num <= arr[high]) {
						low = mid + 1;
					} else {
						high = mid - 1;
					}
				}
			} else {
				if (arr[mid] < arr[high]) {
					if (num > arr[mid] && num <= arr[high]) {
						low = mid + 1;
					} else {
						high = mid - 1;
					}
				} else {
					if (num >= arr[low] && num < arr[mid]) {
						high = mid - 1;
					} else {
						low = mid + 1;
					}
				}
			}
		}
		return false;
	}

	public static void main(String[] args) {
		int[] arr = { 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5 };
		int num = 10;
		System.out.println(isContains(arr, num));

	}
}
```